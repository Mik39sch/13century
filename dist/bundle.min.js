(()=>{"use strict";const t=({max:t,min:e})=>Math.floor(Math.random()*(t-e))+e,e={appElementID:"#app",width:60,height:30,viewWidth:240,viewHeight:120,canvasWidth:960,canvasHeight:480,gamemode:{title:{val:0,text:!0},playing:{val:1,text:!1},gameclear:{val:2,text:!0},gameover:{val:3,text:!0}},debugMode:!0,pixel:16,visibleRange:3};class i{constructor({x:t,y:e,height:i,width:s}){this.x=t,this.y=e,this.height=i,this.width=s,this.angle=0,this.color="blue",this.characterDesign=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],this.color={0:"white",1:"black"}}update(t){this.updateX(t.keyboard,t.stage.maxX,t.stage.minX,t),this.updateY(t.keyboard,t.stage.maxY,t.stage.minY,t),this.updateAngle(t.keyboard),t.stage.isInnerRoom(this.x,this.y,!0),t.stage.isInnerPath(this.x,this.y,t.keyboard,!0)}updateX(t,e,i,s){const o=this.x;t.find((t=>"r"===t))?this.x=this.x+1:t.find((t=>"l"===t))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=o)}updateY(t,e,i,s){const o=this.y;t.find((t=>"u"===t))&&(this.y=this.y-1),t.find((t=>"d"===t))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=o)}updateAngle(t){t.includes("r")||t.includes("l")||!t.includes("u")||t.includes("d")||(this.angle=0),t.includes("r")&&!t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=45),!t.includes("r")||t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=90),t.includes("r")&&!t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=135),t.includes("r")||t.includes("l")||t.includes("u")||!t.includes("d")||(this.angle=180),!t.includes("r")&&t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=225),t.includes("r")||!t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=270),!t.includes("r")&&t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=315)}draw(t){this.drawCharacter(t.ctx)}drawCharacter(t){let i=this.characterDesign.slice();const s=t=>t[0].map(((e,i)=>t.map((t=>t[i])))).reverse();this.angle>45&&this.angle<=135?i=s(s(s(i))):this.angle>135&&this.angle<=225?i=s(s(i)):this.angle>225&&this.angle<=270&&(i=s(i));const o=this.x*e.pixel,n=this.y*e.pixel;let a=0,h=0;for(const e of i){h=0;for(const i of e)t.fillStyle=this.color[i],t.fillRect(o+h,n+a,1,1),h++;a++}}}class s extends i{constructor({x:t,y:e,height:i,width:s}){super({x:t,y:e,height:i,width:s}),this.color={0:"gray",1:"white"},this.speed=1,this.step=0,this.prevD=[]}update(e){let i=[["u"],["u","r"],["r"],["r","d"],["d"],["d","l"],["l"],["l","u"],[]],s=i[t({max:i.length-1,min:0})];this.step>0?(this.step-=1,s=this.prevD):(this.step=t({max:100,min:10}),this.prevD=s),super.updateX(s,e.stage.maxX,e.stage.minX,e),super.updateY(s,e.stage.maxY,e.stage.minY,e),super.updateAngle(s)}draw(t){const e=t.stage.isInnerRoom(this.x,this.y),i=t.stage.isInnerPath(this.x,this.y,[]);(e&&e.visible||i&&i.visible)&&super.draw(t)}}class o{constructor(){this.divideX=t({max:4,min:2}),this.divideY=2,this.stageColor1="rgba(0, 0, 150, 1)",this.stageColor2="rgba(0, 0, 150, 0.5)",this.realms=[],this.connects=[],this.pathPositions=[],this.divide(),this.makeRoom(),this.makePath(),this.maxX=Math.max(...this.realms.map((t=>t.right)))-1,this.minX=Math.min(...this.realms.map((t=>t.left))),this.maxY=Math.max(...this.realms.map((t=>t.bottom)))-1,this.minY=Math.min(...this.realms.map((t=>t.top)))}divide(){let t,i,s,o;const n=new Array(this.divideX),a=new Array(this.divideY),h=e.canvasHeight,r=e.canvasWidth,l=Math.floor(h/e.pixel),d=Math.floor(r/e.pixel);for(t=0;t<this.divideX;t+=1)n[t]=0;for(t=0;t<this.divideY;t+=1)a[t]=0;for(o=this.divideX,t=o;t<d;t+=1)n[Math.floor(Math.random()*this.divideX)]+=1;for(o=this.divideY,t=o;t<l;t+=1)a[Math.floor(Math.random()*this.divideY)]+=1;let c=1,m=2;for(t=0;t<this.divideX;t+=1){for(i=0;i<this.divideY;i+=1)s={left:c,right:c+n[t],top:m,bottom:m+a[i],sizeX:n[t],sizeY:a[i],id:this.realms.length,connectID:[]},this.realms.push(Object.assign({},s)),m+=a[i];m=2,c+=n[t]}}makeRoom(){let e,i,s,o,n,a,h,r,l,d,c,m;i=0,s=0,o=0,h=0,r=0,m=0;const p=(t,e,i,s,o)=>(t.roomLeft=e,t.roomTop=i,t.roomSizeX=s,t.roomSizeY=o,t.roomRight=e+s-1,t.roomBottom=i+o-1,t.visible=!1,t.know=!1,t);for(e=0;e<this.realms.length;e++){const u=this.realms[e];if(u.sizeX*u.sizeY<25)this.realms[e]=p(u,u.left+2,u.top+2,u.sizeX-4,u.sizeY-4);else{for(i=0,c=!0;c;){if(i+=1,i>100){h=u.sizeX-4,r=u.sizeY-4;break}l=u.sizeX-4,d=u.sizeY-4,h=t({max:l,min:5}),r=t({max:d,min:5}),m=h*r/(u.sizeX*u.sizeY),c=!0,h*r<25&&(c=!1),m<.4&&(c=!1)}n=u.sizeX-h-4,s=n>0?t({max:n,min:2}):2,a=u.sizeY-r-4,o=a>0?t({max:a,min:2}):2,this.realms[e]=p(u,u.left+s,u.top+o,h,r)}}}makePath(){let t,e,i;for(t=0;t<this.realms.length;t+=1)e=this.getAdjacentRealmIndices(t),i=Math.floor(Math.random()*e.length),this.addConnect(this.realms[t],this.realms[e[i]]);for(const t of this.connects)this.drawConnect(null,t,!1)}makePathObject(t,e){let i=this.pathPositions.find((i=>i.x===t&&i.y===e));i||(i={x:t,y:e,visible:!1,know:!1},this.pathPositions.push(i))}addConnect(e,i){let s,o,n,a,h,r;if(this.connects.some((t=>t.fromId===e.id&&t.toId===i.id||t.fromId===i.id&&t.toId===e.id)))return;const l={fromId:e.id,toId:i.id},d=e=>t({max:e.roomBottom-2,min:e.roomTop+2}),c=e=>t({max:e.roomRight-2,min:e.roomLeft+2});e.left===i.right&&(s=e.roomLeft-1,o=d(e),n=i.roomRight+1,a=d(i),r=e.roomLeft-e.left,h=3),i.left===e.right&&(s=e.roomRight+1,o=d(e),n=i.roomLeft-1,a=d(i),r=e.right-e.roomRight,h=1),e.top===i.bottom&&(s=c(e),o=e.roomTop-1,n=c(i),a=i.roomBottom+1,r=e.roomTop-e.top,h=0),i.top===e.bottom&&(s=c(e),o=e.roomBottom+1,n=c(i),a=i.roomTop-1,r=e.bottom-e.roomBottom,h=2),l.startX=s,l.startY=o,l.endX=n,l.endY=a,l.middle=r,l.direction=h,this.connects.push(Object.assign({},l)),e.connectID.push(i.id),i.connectID.push(e.id)}getAdjacentRealmIndices(t){const e=[],i=this.realms[t];for(let s=0;s<this.realms.length;s+=1)t!==s&&this.isAdjacent(i,this.realms[s])&&e.push(s);return e}isAdjacent(t,e){if(t.left===e.right||e.left===t.right){if(t.top<=e.bottom&&t.top>=e.top)return!0;if(t.bottom>=e.top&&t.bottom<=e.bottom)return!0}if(t.top===e.bottom||e.top===t.bottom){if(t.left>=e.left&&t.left<=e.right)return!0;if(t.right>=e.left&&t.right<=e.right)return!0}return!1}update(t){for(const t of this.realms)t.visible=!1;for(const t of this.pathPositions)t.visible=!1}draw(t){for(const e of this.realms)this.drawRoom(t.ctx,e);for(const e of this.connects)this.drawConnect(t.ctx,e)}drawRoom(t,i){t.lineWidth=2,t.strokeStyle=i.visible?this.stageColor1:this.stageColor2,t.fillStyle=i.visible?this.stageColor1:this.stageColor2,t.strokeRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel),(i.visible||i.know)&&t.fillRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel)}drawConnect(t,e,i=!0){var s,o,n,a,h;for(n=e.startX,a=e.startY,o=e.direction,h=e.middle,s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1);for(o%2==0?(h=Math.abs(e.startX-e.endX),e.startX>e.endX&&(o=3),e.startX<e.endX&&(o=1)):(h=Math.abs(e.startY-e.endY)+1,e.startY>e.endY&&(o=0),e.startY<e.endY&&(o=2)),s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),s!==h-1&&(0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1));for(h=(o=e.direction)%2==0?Math.abs(a-e.endY):Math.abs(n-e.endX),s=0;s<h;s+=1)0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1),i?this.drawPath(t,n,a):this.makePathObject(n,a)}drawPath(t,i,s){const o=this.pathPositions.find((t=>t.x===i&&t.y===s));(o.visible||o.know)&&(t.fillStyle=o.visible?this.stageColor1:this.stageColor2,t.fillRect(e.pixel*i,e.pixel*s,e.pixel,e.pixel))}hitWall(t,e,i=["u"]){return!this.isInnerRoom(t,e)&&!this.isInnerPath(t,e,i)}isInnerRoom(t,e,i=!1){for(const s of this.realms)if(s.roomLeft<=t&&t<=s.roomRight&&s.roomTop<=e&&e<=s.roomBottom){if(i){s.visible=!0,s.know=!0;for(const t of this.pathPositions)t.x>=s.roomLeft-1&&t.x<=s.roomRight+1&&t.y>=s.roomTop-1&&t.y<=s.roomBottom+1&&(t.visible=!0,t.know=!0)}return s}return null}isInnerPath(t,i,s,o=!1){const n=s.length>0?s[0]:null,a=[];if("u"===n)for(let s=1;s<=e.visibleRange;s++)a.push({x:t,y:i-s});if("d"===n)for(let s=1;s<=e.visibleRange;s++)a.push({x:t,y:i+s});if("u"!==n&&"d"!==n||(a.push({x:t+1,y:i}),a.push({x:t-1,y:i})),"l"===n)for(let s=1;s<=e.visibleRange;s++)a.push({x:t-s,y:i});if("r"===n)for(let s=1;s<=e.visibleRange;s++)a.push({x:t+s,y:i});"l"!==n&&"r"!==n||(a.push({x:t,y:i+1}),a.push({x:t,y:i-1}));let h=null;for(const e of this.pathPositions)e.x===t&&e.y===i&&(o&&(e.visible=!0,e.know=!0),h=e),o&&a.some((t=>t.x===e.x&&t.y===e.y))&&(e.visible=!0,e.know=!0);return h}}class n{constructor(t){this.camera=new BABYLON.UniversalCamera("camera",new BABYLON.Vector3(0,30,0),t.scene),this.camera.attachControl(t.canvas3DEl,!0),new BABYLON.PointLight("light",new BABYLON.Vector3(10,10,0),t.scene)}drawMap(t,i){let s;const o=new BABYLON.StandardMaterial("material",t.scene);let n,a;for(o.emissiveColor=new BABYLON.Color3(0,.58,.86),n=0;n<e.width;n++)for(a=0;a<e.height;a++)s=BABYLON.Mesh.CreateBox(`wall-${n}-${a}`,2,t.scene),s.position.x=n,s.position.y=a,s.material=o;for(const e of i.realms)for(n=e.roomLeft;n<=e.roomRight;n++)for(a=e.roomTop;a<=e.roomBottom;a++)s=t.scene.getMeshByName(`wall-${n}-${a}`),s&&s.dispose();console.log(i.pathPositions);let h=1;for({x:n,y:a}of i.pathPositions)s=t.scene.getMeshByName(`wall-${n}-${a}`),s&&(console.log(h,s),s.dispose(),s=t.scene.getMeshByName(`wall-${n}-${a}`),console.log("removed",s),h++)}update(t){}draw(t){}}class a{constructor(a,h){this.loadCount=0,this.gamemode=e.gamemode.playing.val,this.keyboard=[],this.canvasEl=void 0,this.ctx=void 0,this.displayCtx=void 0,this.stage=new o;const r=()=>{const e=this.stage.realms[t({max:this.stage.realms.length-1,min:0})];return[t({max:e.roomRight,min:e.roomLeft}),t({max:e.roomBottom,min:e.roomTop})]},[l,d]=r();this.player=new i({x:l,y:d,height:e.pixel,width:e.pixel});const[c,m]=r();this.enemies=[new s({x:c,y:m,height:e.pixel,width:e.pixel})];const p=document.querySelector(e.appElementID);this._createCanvasEl(p,a,h),this.setKeyEvent(),this.stage.isInnerRoom(l,d,!0),this.stage.isInnerPath(l,d,["u"],!0),this.threeDrawer=new n(this),this.threeDrawer.drawMap(this,this.stage)}setKeyEvent(){this.addKeydownEventListener(document,"keydown")}addKeydownEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[this._adjustKeyCode(t.code)]};i?t.addEventListener(e,(()=>s(i))):t.addEventListener(e,s)}addKeyupEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[]};i?t.addEventListener(e,(()=>s())):t.addEventListener(e,s)}run(){this.engine.runRenderLoop(this._draw.bind(this))}_adjustKeyCode(t){const e={l:["ArrowLeft"],r:["ArrowRight"],u:["ArrowUp"],d:["ArrowDown"]};for(const[i,s]of Object.entries(e))if(s.includes(t))return i;return t}_createCanvasEl(t,i,s){const[o,n]=[i,s];let a=o;[t.style.width,t.style.height]=[`${a}px`,`${n}px`],this.canvasEl=document.createElement("canvas"),[this.canvasEl.width,this.canvasEl.height]=[o,n],this.ctx=this.canvasEl.getContext("2d");const h=document.createElement("canvas");[h.style.width,h.style.height]=[`${e.viewWidth}px`,`${e.viewHeight}px`],[h.width,h.height]=[o,n],this.displayCtx=h.getContext("2d"),t.appendChild(h),this.canvas3DEl=document.createElement("canvas"),[this.canvas3DEl.style.width,this.canvas3DEl.style.height]=[o,n],t.appendChild(this.canvas3DEl),this.engine=new BABYLON.Engine(this.canvas3DEl),this.scene=new BABYLON.Scene(this.engine),this.scene.clearColor=new BABYLON.Color3(.8,.8,.8)}_draw(){this.scene.render(),this.drawMap()}update(){this.stage.update(this),this.player.update(this);for(const t of this.enemies)t.update(this)}drawMap(){this.ctx.save(),this.ctx.fillStyle="#205030",this.ctx.fillRect(0,0,e.canvasWidth,e.canvasHeight),this.stage.draw(this),this.ctx.restore(),this.displayCtx.drawImage(this.canvasEl,0,0)}}class h extends a{constructor(t,i){const s=document.querySelector(e.appElementID),o=document.createElement("button");[o.style.width,o.style.height]=["50px",`${i}px`],o.innerText="<<<",o.id="leftbtn",s.appendChild(o);const n=document.createElement("button");[n.style.width,n.style.height]=["50px",`${i}px`],n.innerText=">>>",n.id="rightbtn",s.appendChild(n);const a=document.createElement("button");[a.style.width,a.style.height]=["50px",`${i}px`],a.innerText="UP",a.id="upbtn",s.appendChild(a);const h=document.createElement("button");[h.style.width,h.style.height]=["50px",`${i}px`],h.innerText="DOWN",h.id="downbtn",s.appendChild(h),super(t,i)}setKeyEvent(){const t=document.querySelector("#leftbtn"),e=document.querySelector("#rightbtn"),i=document.querySelector("#upbtn"),s=document.querySelector("#downbtn");["mousedown","touchstart"].forEach((o=>{this.addKeydownEventListener(t,o,{code:"l"}),this.addKeydownEventListener(e,o,{code:"r"}),this.addKeydownEventListener(i,o,{code:"u"}),this.addKeydownEventListener(s,o,{code:"d"})}))}}const r=[],l=()=>{let t;t=navigator.userAgent.match(/iPhone|Android.+Mobile/)?new h(e.canvasWidth,e.canvasHeight):new a(e.canvasWidth,e.canvasHeight),t.run()},d=navigator.userAgent.toLowerCase(),c=d.indexOf("iphone")>-1,m=d.indexOf("ipad")>-1,p=d.indexOf("android")>-1&&d.indexOf("mobile")>-1,u=d.indexOf("android")>-1&&-1==d.indexOf("mobile");(c||m)&&(window.onorientationchange=f),(p||u)&&(window.onresize=f);const g=f();function f(){return 90==Math.abs(window.orientation)?"横向き":"縦向き"}if((c||m||p||u)&&"縦向き"===g)document.getElementById("app").innerHTML="横向きにしてください";else{let t=0;0===r.length&&l();for(var x=0;x<r.length;++x)r[x].onload=function(){++t,t==r.length&&l()}}})();