(()=>{"use strict";const t=({max:t,min:e})=>Math.floor(Math.random()*(t-e))+e,e={appElementID:"#app",wrapperElementID:"#wrapper",width:60,height:30,viewWidth:240,viewHeight:120,canvasWidth:960,canvasHeight:480,gamemode:{title:{val:0,text:!0},playing:{val:1,text:!1},gameclear:{val:2,text:!0},gameover:{val:3,text:!0}},debugMode:!0,pixel:16,visibleRange:3};class i{constructor({x:t,y:e,height:i,width:s}){this.x=t,this.y=e,this.height=i,this.width=s,this.angle="u",this.prevAngle="u",this.color="blue",this.characterDesign=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],this.color={0:"white",1:"black"}}update(t){(t.keyboard.includes("r")||t.keyboard.includes("l"))&&this.updateAngle(t.keyboard),(t.keyboard.includes("u")||t.keyboard.includes("d"))&&(this.updateX(t.keyboard,t.stage.maxX,t.stage.minX,t),this.updateY(t.keyboard,t.stage.maxY,t.stage.minY,t)),t.stage.isInnerRoom(this.x,this.y,!0),t.stage.isInnerPath(this.x,this.y,this.angle,!0)}updateX(t,e,i,s){const n=this.x;"r"===this.angle&&t.includes("u")||"l"===this.angle&&t.includes("d")?this.x=this.x+1:("r"===this.angle&&t.includes("d")||"l"===this.angle&&t.includes("u"))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=n)}updateY(t,e,i,s){const n=this.y;"u"===this.angle&&t.includes("u")||"d"===this.angle&&t.includes("d")?this.y=this.y-1:("u"===this.angle&&t.includes("d")||"d"===this.angle&&t.includes("u"))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=n)}updateAngle(t){this.prevAngle=this.angle,t.includes("r")&&("u"===this.angle?this.angle="r":"r"===this.angle?this.angle="d":"d"===this.angle?this.angle="l":"l"===this.angle&&(this.angle="u")),t.includes("l")&&("u"===this.angle?this.angle="l":"r"===this.angle?this.angle="u":"d"===this.angle?this.angle="r":"l"===this.angle&&(this.angle="d"))}draw(t){this.drawCharacter(t.ctx)}drawCharacter(t){let i=this.characterDesign.slice();const s=t=>t[0].map(((e,i)=>t.map((t=>t[i])))).reverse();this.angle>45&&this.angle<=135?i=s(s(s(i))):this.angle>135&&this.angle<=225?i=s(s(i)):this.angle>225&&this.angle<=270&&(i=s(i));const n=this.x*e.pixel,o=this.y*e.pixel;let a=0,h=0;for(const e of i){h=0;for(const i of e)t.fillStyle=this.color[i],t.fillRect(n+h,o+a,1,1),h++;a++}}}class s extends i{constructor({x:t,y:e,height:i,width:s}){super({x:t,y:e,height:i,width:s}),this.color={0:"gray",1:"white"},this.speed=1,this.step=0,this.prevD=[]}update(e){let i=[["u"],["u","r"],["r"],["r","d"],["d"],["d","l"],["l"],["l","u"],[]],s=i[t({max:i.length-1,min:0})];this.step>0?(this.step-=1,s=this.prevD):(this.step=t({max:100,min:10}),this.prevD=s),this.updateX(s,e.stage.maxX,e.stage.minX,e),this.updateY(s,e.stage.maxY,e.stage.minY,e),this.updateAngle(s)}updateX(t,e,i,s){const n=this.x;t.find((t=>"r"===t))?this.x=this.x+1:t.find((t=>"l"===t))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=n)}updateY(t,e,i,s){const n=this.y;t.find((t=>"u"===t))&&(this.y=this.y-1),t.find((t=>"d"===t))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=n)}updateAngle(t){t.includes("r")||t.includes("l")||!t.includes("u")||t.includes("d")||(this.angle=0),t.includes("r")&&!t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=45),!t.includes("r")||t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=90),t.includes("r")&&!t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=135),t.includes("r")||t.includes("l")||t.includes("u")||!t.includes("d")||(this.angle=180),!t.includes("r")&&t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=225),t.includes("r")||!t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=270),!t.includes("r")&&t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=315)}draw(t){const e=t.stage.isInnerRoom(this.x,this.y),i=t.stage.isInnerPath(this.x,this.y,[]);(e&&e.visible||i&&i.visible)&&super.draw(t)}}class n{constructor(){this.divideX=t({max:4,min:2}),this.divideY=2,this.stageColor1="rgba(0, 0, 150, 1)",this.stageColor2="rgba(0, 0, 150, 0.5)",this.defaultVisible=!0,this.realms=[],this.connects=[],this.pathPositions=[],this.divide(),this.makeRoom(),this.makePath(),this.maxX=Math.max(...this.realms.map((t=>t.right)))-1,this.minX=Math.min(...this.realms.map((t=>t.left))),this.maxY=Math.max(...this.realms.map((t=>t.bottom)))-1,this.minY=Math.min(...this.realms.map((t=>t.top)))}divide(){let t,i,s,n;const o=new Array(this.divideX),a=new Array(this.divideY),h=e.canvasHeight,r=e.canvasWidth,l=Math.floor(h/e.pixel),d=Math.floor(r/e.pixel);for(t=0;t<this.divideX;t+=1)o[t]=0;for(t=0;t<this.divideY;t+=1)a[t]=0;for(n=this.divideX,t=n;t<d;t+=1)o[Math.floor(Math.random()*this.divideX)]+=1;for(n=this.divideY,t=n;t<l;t+=1)a[Math.floor(Math.random()*this.divideY)]+=1;let c=1,m=2;for(t=0;t<this.divideX;t+=1){for(i=0;i<this.divideY;i+=1)s={left:c,right:c+o[t],top:m,bottom:m+a[i],sizeX:o[t],sizeY:a[i],id:this.realms.length,connectID:[]},this.realms.push(Object.assign({},s)),m+=a[i];m=2,c+=o[t]}}makeRoom(){let e,i,s,n,o,a,h,r,l,d,c,m;i=0,s=0,n=0,h=0,r=0,m=0;const u=(t,e,i,s,n)=>(t.roomLeft=e,t.roomTop=i,t.roomSizeX=s,t.roomSizeY=n,t.roomRight=e+s-1,t.roomBottom=i+n-1,t.visible=this.defaultVisible,t.know=!1,t);for(e=0;e<this.realms.length;e++){const g=this.realms[e];if(g.sizeX*g.sizeY<25)this.realms[e]=u(g,g.left+2,g.top+2,g.sizeX-4,g.sizeY-4);else{for(i=0,c=!0;c;){if(i+=1,i>100){h=g.sizeX-4,r=g.sizeY-4;break}l=g.sizeX-4,d=g.sizeY-4,h=t({max:l,min:5}),r=t({max:d,min:5}),m=h*r/(g.sizeX*g.sizeY),c=!0,h*r<25&&(c=!1),m<.4&&(c=!1)}o=g.sizeX-h-4,s=o>0?t({max:o,min:2}):2,a=g.sizeY-r-4,n=a>0?t({max:a,min:2}):2,this.realms[e]=u(g,g.left+s,g.top+n,h,r)}}}makePath(){let t,e,i;for(t=0;t<this.realms.length;t+=1)e=this.getAdjacentRealmIndices(t),i=Math.floor(Math.random()*e.length),this.addConnect(this.realms[t],this.realms[e[i]]);for(const t of this.connects)this.drawConnect(null,t,!1)}makePathObject(t,e){let i=this.pathPositions.find((i=>i.x===t&&i.y===e));i||(i={x:t,y:e,visible:this.defaultVisible,know:!1},this.pathPositions.push(i))}addConnect(e,i){let s,n,o,a,h,r;if(this.connects.some((t=>t.fromId===e.id&&t.toId===i.id||t.fromId===i.id&&t.toId===e.id)))return;const l={fromId:e.id,toId:i.id},d=e=>t({max:e.roomBottom-2,min:e.roomTop+2}),c=e=>t({max:e.roomRight-2,min:e.roomLeft+2});e.left===i.right&&(s=e.roomLeft-1,n=d(e),o=i.roomRight+1,a=d(i),r=e.roomLeft-e.left,h=3),i.left===e.right&&(s=e.roomRight+1,n=d(e),o=i.roomLeft-1,a=d(i),r=e.right-e.roomRight,h=1),e.top===i.bottom&&(s=c(e),n=e.roomTop-1,o=c(i),a=i.roomBottom+1,r=e.roomTop-e.top,h=0),i.top===e.bottom&&(s=c(e),n=e.roomBottom+1,o=c(i),a=i.roomTop-1,r=e.bottom-e.roomBottom,h=2),l.startX=s,l.startY=n,l.endX=o,l.endY=a,l.middle=r,l.direction=h,this.connects.push(Object.assign({},l)),e.connectID.push(i.id),i.connectID.push(e.id)}getAdjacentRealmIndices(t){const e=[],i=this.realms[t];for(let s=0;s<this.realms.length;s+=1)t!==s&&this.isAdjacent(i,this.realms[s])&&e.push(s);return e}isAdjacent(t,e){if(t.left===e.right||e.left===t.right){if(t.top<=e.bottom&&t.top>=e.top)return!0;if(t.bottom>=e.top&&t.bottom<=e.bottom)return!0}if(t.top===e.bottom||e.top===t.bottom){if(t.left>=e.left&&t.left<=e.right)return!0;if(t.right>=e.left&&t.right<=e.right)return!0}return!1}update(t){for(const t of this.realms)t.visible=this.defaultVisible;for(const t of this.pathPositions)t.visible=!1}draw(t){for(const e of this.realms)this.drawRoom(t.ctx,e);for(const e of this.connects)this.drawConnect(t.ctx,e)}drawRoom(t,i){t.lineWidth=2,t.strokeStyle=i.visible?this.stageColor1:this.stageColor2,t.fillStyle=i.visible?this.stageColor1:this.stageColor2,t.strokeRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel),(i.visible||i.know)&&t.fillRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel)}drawConnect(t,e,i=!0){var s,n,o,a,h;for(o=e.startX,a=e.startY,n=e.direction,h=e.middle,s=0;s<h;s+=1)i?this.drawPath(t,o,a):this.makePathObject(o,a),0===n&&(a-=1),1===n&&(o+=1),2===n&&(a+=1),3===n&&(o-=1);for(n%2==0?(h=Math.abs(e.startX-e.endX),e.startX>e.endX&&(n=3),e.startX<e.endX&&(n=1)):(h=Math.abs(e.startY-e.endY)+1,e.startY>e.endY&&(n=0),e.startY<e.endY&&(n=2)),s=0;s<h;s+=1)i?this.drawPath(t,o,a):this.makePathObject(o,a),s!==h-1&&(0===n&&(a-=1),1===n&&(o+=1),2===n&&(a+=1),3===n&&(o-=1));for(h=(n=e.direction)%2==0?Math.abs(a-e.endY):Math.abs(o-e.endX),s=0;s<h;s+=1)0===n&&(a-=1),1===n&&(o+=1),2===n&&(a+=1),3===n&&(o-=1),i?this.drawPath(t,o,a):this.makePathObject(o,a)}drawPath(t,i,s){const n=this.pathPositions.find((t=>t.x===i&&t.y===s));(n.visible||n.know)&&(t.fillStyle=n.visible?this.stageColor1:this.stageColor2,t.fillRect(e.pixel*i,e.pixel*s,e.pixel,e.pixel))}hitWall(t,e,i=["u"]){return!this.isInnerRoom(t,e)&&!this.isInnerPath(t,e,i)}isInnerRoom(t,e,i=!1){for(const s of this.realms)if(s.roomLeft<=t&&t<=s.roomRight&&s.roomTop<=e&&e<=s.roomBottom){if(i){s.visible=!0,s.know=!0;for(const t of this.pathPositions)t.x>=s.roomLeft-1&&t.x<=s.roomRight+1&&t.y>=s.roomTop-1&&t.y<=s.roomBottom+1&&(t.visible=!0,t.know=!0)}return s}return null}isInnerPath(t,i,s,n=!1){const o=s.length>0?s[0]:null,a=[];if("u"===o)for(let s=1;s<=e.visibleRange;s++)a.push({x:t,y:i-s});if("d"===o)for(let s=1;s<=e.visibleRange;s++)a.push({x:t,y:i+s});if("u"!==o&&"d"!==o||(a.push({x:t+1,y:i}),a.push({x:t-1,y:i})),"l"===o)for(let s=1;s<=e.visibleRange;s++)a.push({x:t-s,y:i});if("r"===o)for(let s=1;s<=e.visibleRange;s++)a.push({x:t+s,y:i});"l"!==o&&"r"!==o||(a.push({x:t,y:i+1}),a.push({x:t,y:i-1}));let h=null;for(const e of this.pathPositions)e.x===t&&e.y===i&&(n&&(e.visible=!0,e.know=!0),h=e),n&&a.some((t=>t.x===e.x&&t.y===e.y))&&(e.visible=!0,e.know=!0);return h}}class o{constructor(t){this.camera=new BABYLON.FreeCamera("camera",new BABYLON.Vector3(t.player.x,.5,e.height-t.player.y),t.scene),this.camera.rotation.y=0,this.light=new BABYLON.SpotLight("spotLight",new BABYLON.Vector3(t.player.x,2,e.height-t.player.y),new BABYLON.Vector3(0,-2,2),Math.PI/3,80,t.scene),this.light.diffuse=new BABYLON.Color3(1,1,1),this.light.specular=new BABYLON.Color3(1,1,1);const i=new BABYLON.StandardMaterial("material",t.scene);i.emissiveColor=new BABYLON.Color3(100,0,0),this.enemy=BABYLON.Mesh.CreateBox("enemy",1,t.scene),this.enemy.position.x=t.enemies[0].x,this.enemy.position.z=e.height-t.enemies[0].y,this.enemy.position.y=.5,this.enemy.material=i}drawMap(t,i){let s,n;const o="./assets/images/",a=new BABYLON.StandardMaterial("material",t.scene);a.diffuseTexture=new BABYLON.Texture(o+"floor.png.jpg",t.scene),a.diffuseTexture.uScale=e.canvasWidth,a.diffuseTexture.vScale=e.canvasHeight,a.specularColor=new BABYLON.Color3(.2,.2,.2);const h=new BABYLON.StandardMaterial("skyMaterial",t.scene);h.emissiveColor=new BABYLON.Color3(160,216,239);BABYLON.Mesh.CreateBox("skyBox",e.width,t.scene).material=h;const r=new BABYLON.StandardMaterial("g-material",t.scene);r.diffuseTexture=new BABYLON.Texture(o+"speckles.jpg",t.scene),r.diffuseTexture.uScale=e.canvasWidth,r.diffuseTexture.vScale=e.canvasHeight,r.specularColor=new BABYLON.Color3(.2,.2,.2);let l,d;for(BABYLON.Mesh.CreateGround("ground",e.canvasWidth,e.canvasHeight,0,t.scene,!1).material=r,l=0;l<e.width;l++)for(d=0;d<e.height;d++)s=BABYLON.Mesh.CreateBox(`wall-${l}-${d}`,1,t.scene),s.position.x=l,s.position.z=d,s.material=a,n=BABYLON.Mesh.CreateBox(`wall-${l}-${d}-1`,1,t.scene),n.position.x=l,n.position.z=d,n.position.y=1,n.material=a;for(const o of i.realms)for(l=o.roomLeft;l<=o.roomRight;l++)for(d=o.roomTop;d<=o.roomBottom;d++)s=t.scene.getMeshByName(`wall-${l}-${e.height-d}`),s&&s.dispose(),n=t.scene.getMeshByName(`wall-${l}-${e.height-d}-1`),n&&n.dispose();for({x:l,y:d}of i.pathPositions)s=t.scene.getMeshByName(`wall-${l}-${e.height-d}`),s&&s.dispose(),n=t.scene.getMeshByName(`wall-${l}-${e.height-d}-1`),n&&n.dispose()}update(t){"u"===t.player.angle?(this.camera.rotation.y=0,this.light.direction.z=2,this.light.direction.x=0):"r"===t.player.angle?(this.camera.rotation.y=Math.PI/2,this.light.direction.z=0,this.light.direction.x=2):"d"===t.player.angle?(this.camera.rotation.y=Math.PI,this.light.direction.z=-2,this.light.direction.x=0):"l"===t.player.angle&&(this.camera.rotation.y=Math.PI+Math.PI/2,this.light.direction.z=0,this.light.direction.x=-2),this.camera.position.x=t.player.x,this.camera.position.z=e.height-t.player.y,this.light.position.x=t.player.x,this.light.position.z=e.height-t.player.y,this.enemy.position.x=t.enemies[0].x,this.enemy.position.z=e.height-t.enemies[0].y}draw(t){}}class a{constructor(a,h){this.loadCount=0,this.gamemode=e.gamemode.playing.val,this.keyboard=[],this.canvasEl=void 0,this.ctx=void 0,this.displayCtx=void 0,this.stage=new n,this.prevTime=performance.now();const r=()=>{const e=this.stage.realms[t({max:this.stage.realms.length-1,min:0})];return[t({max:e.roomRight,min:e.roomLeft}),t({max:e.roomBottom,min:e.roomTop})]},[l,d]=r();this.player=new i({x:l,y:d,height:e.pixel,width:e.pixel});const[c,m]=r();this.enemies=[new s({x:c,y:m,height:e.pixel,width:e.pixel})];const u=document.querySelector(e.appElementID),g=document.querySelector(e.wrapperElementID);this._createCanvasEl(u,g,a,h),this.setKeyEvent(),this.stage.isInnerRoom(l,d,!0),this.stage.isInnerPath(l,d,["u"],!0),this.threeDrawer=new o(this),this.threeDrawer.drawMap(this,this.stage)}setKeyEvent(){this.addKeyupEventListener(document,"keyup")}addKeydownEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[this._adjustKeyCode(t.code)],this._draw()};i?t.addEventListener(e,(()=>s(i))):t.addEventListener(e,s)}addKeyupEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[this._adjustKeyCode(t.code)],this._draw()};i?t.addEventListener(e,(()=>s(i))):t.addEventListener(e,s)}run(){this._draw()}_adjustKeyCode(t){const e={l:["ArrowLeft"],r:["ArrowRight"],u:["ArrowUp"],d:["ArrowDown"]};for(const[i,s]of Object.entries(e))if(s.includes(t))return i;return t}_createCanvasEl(t,i,s,n){const[o,a]=[s,n];let h=o;[t.style.width,t.style.height]=[`${h}px`,`${a}px`],this.canvasEl=document.createElement("canvas"),[this.canvasEl.width,this.canvasEl.height]=[o,a],this.ctx=this.canvasEl.getContext("2d");const r=document.createElement("canvas");[r.style.width,r.style.height]=[`${e.viewWidth}px`,`${e.viewHeight}px`],[r.width,r.height]=[o,a],r.style.zIndex=1,this.displayCtx=r.getContext("2d"),i.appendChild(r),this.canvas3DEl=document.createElement("canvas"),[this.canvas3DEl.style.width,this.canvas3DEl.style.height]=[o,a],this.canvas3DEl.style.zIndex=0,i.appendChild(this.canvas3DEl),this.engine=new BABYLON.Engine(this.canvas3DEl),this.scene=new BABYLON.Scene(this.engine),this.scene.clearColor=new BABYLON.Color3(.8,.8,.8)}_draw(){this.update(),this.drawMap(),this.scene.render()}update(){this.stage.update(this),this.player.update(this);for(const t of this.enemies)t.update(this);this.threeDrawer.update(this)}drawMap(){this.ctx.save(),this.ctx.fillStyle="#205030",this.ctx.fillRect(0,0,e.canvasWidth,e.canvasHeight),this.stage.draw(this);for(const t of this.enemies)t.draw(this);this.player.draw(this),this.ctx.restore(),this.displayCtx.drawImage(this.canvasEl,0,0)}}class h extends a{constructor(t,i){const s=document.querySelector(e.appElementID),n=document.createElement("button");[n.style.width,n.style.height]=["50px",`${i}px`],n.innerText="<<<",n.id="leftbtn",s.appendChild(n);const o=document.createElement("button");[o.style.width,o.style.height]=["50px",`${i}px`],o.innerText=">>>",o.id="rightbtn",s.appendChild(o);const a=document.createElement("button");[a.style.width,a.style.height]=["50px",`${i}px`],a.innerText="UP",a.id="upbtn",s.appendChild(a);const h=document.createElement("button");[h.style.width,h.style.height]=["50px",`${i}px`],h.innerText="DOWN",h.id="downbtn",s.appendChild(h),super(t,i)}setKeyEvent(){const t=document.querySelector("#leftbtn"),e=document.querySelector("#rightbtn"),i=document.querySelector("#upbtn"),s=document.querySelector("#downbtn");["mousedown","touchstart"].forEach((n=>{this.addKeydownEventListener(t,n,{code:"l"}),this.addKeydownEventListener(e,n,{code:"r"}),this.addKeydownEventListener(i,n,{code:"u"}),this.addKeydownEventListener(s,n,{code:"d"})}))}}const r=[],l=()=>{let t;t=navigator.userAgent.match(/iPhone|Android.+Mobile/)?new h(e.canvasWidth,e.canvasHeight):new a(e.canvasWidth,e.canvasHeight),t.run()},d=navigator.userAgent.toLowerCase(),c=d.indexOf("iphone")>-1,m=d.indexOf("ipad")>-1,u=d.indexOf("android")>-1&&d.indexOf("mobile")>-1,g=d.indexOf("android")>-1&&-1==d.indexOf("mobile");(c||m)&&(window.onorientationchange=x),(u||g)&&(window.onresize=x);const p=x();function x(){return 90==Math.abs(window.orientation)?"横向き":"縦向き"}if((c||m||u||g)&&"縦向き"===p)document.getElementById("app").innerHTML="横向きにしてください";else{let t=0;0===r.length&&l();for(var y=0;y<r.length;++y)r[y].onload=function(){++t,t==r.length&&l()}}})();