(()=>{"use strict";const t=({max:t,min:e})=>Math.floor(Math.random()*(t-e))+e,e={appElementID:"#app",canvasWidth:window.innerWidth,canvasHeight:window.innerHeight,gamemode:{title:{val:0,text:!0},playing:{val:1,text:!1},gameclear:{val:2,text:!0},gameover:{val:3,text:!0}},debugMode:!0,pixel:16,visibleRange:3};class i{constructor({x:t,y:e,height:i,width:s}){this.x=t,this.y=e,this.height=i,this.width=s,this.angle=0,this.color="blue",this.characterDesign=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,0,0,0,1,0,0,1,0,1],[1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],this.color={0:"white",1:"black"}}update(t){this.updateX(t.keyboard,t.stage.maxX,t.stage.minX,t),this.updateY(t.keyboard,t.stage.maxY,t.stage.minY,t),this.updateAngle(t.keyboard),t.stage.isInnerRoom(this.x,this.y,!0),t.stage.isInnerPath(this.x,this.y,t.keyboard,!0)}updateX(t,e,i,s){const o=this.x;t.find((t=>"r"===t))?this.x=this.x+1:t.find((t=>"l"===t))&&(this.x=this.x-1),this.x>=e&&(this.x=e),this.x<=i&&(this.x=i),s.stage.hitWall(this.x,this.y)&&(this.x=o)}updateY(t,e,i,s){const o=this.y;t.find((t=>"u"===t))&&(this.y=this.y-1),t.find((t=>"d"===t))&&(this.y=this.y+1),this.y>=e&&(this.y=e),this.y<=i&&(this.y=i),s.stage.hitWall(this.x,this.y)&&(this.y=o)}updateAngle(t){t.includes("r")||t.includes("l")||!t.includes("u")||t.includes("d")||(this.angle=0),t.includes("r")&&!t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=45),!t.includes("r")||t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=90),t.includes("r")&&!t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=135),t.includes("r")||t.includes("l")||t.includes("u")||!t.includes("d")||(this.angle=180),!t.includes("r")&&t.includes("l")&&!t.includes("u")&&t.includes("d")&&(this.angle=225),t.includes("r")||!t.includes("l")||t.includes("u")||t.includes("d")||(this.angle=270),!t.includes("r")&&t.includes("l")&&t.includes("u")&&!t.includes("d")&&(this.angle=315)}draw(t){this.drawCharacter(t.ctx)}drawCharacter(t){let i=this.characterDesign.slice();const s=t=>t[0].map(((e,i)=>t.map((t=>t[i])))).reverse();this.angle>45&&this.angle<=135?i=s(s(s(i))):this.angle>135&&this.angle<=225?i=s(s(i)):this.angle>225&&this.angle<=270&&(i=s(i));const o=this.x*e.pixel,n=this.y*e.pixel;let a=0,h=0;for(const e of i){h=0;for(const i of e)t.fillStyle=this.color[i],t.fillRect(o+h,n+a,1,1),h++;a++}}}class s extends i{constructor({x:t,y:e,height:i,width:s}){super({x:t,y:e,height:i,width:s}),this.color={0:"gray",1:"white"},this.speed=1,this.step=0,this.prevD=[]}update(e){let i=[["u"],["u","r"],["r"],["r","d"],["d"],["d","l"],["l"],["l","u"],[]],s=i[t({max:i.length-1,min:0})];this.step>0?(this.step-=1,s=this.prevD):(this.step=t({max:100,min:10}),this.prevD=s),super.updateX(s,e.stage.maxX,e.stage.minX,e),super.updateY(s,e.stage.maxY,e.stage.minY,e),super.updateAngle(s)}draw(t){const e=t.stage.isInnerRoom(this.x,this.y),i=t.stage.isInnerPath(this.x,this.y,[]);(e&&e.visible||i&&i.visible)&&super.draw(t)}}class o{constructor(){this.divideX=t({max:4,min:2}),this.divideY=t({max:4,min:2}),this.stageColor1="rgba(0, 0, 150, 1)",this.stageColor2="rgba(0, 0, 150, 0.5)",this.realms=[],this.connects=[],this.pathPositions=[],this.divide(),this.makeRoom(),this.makePath(),this.maxX=Math.max(...this.realms.map((t=>t.right)))-1,this.minX=Math.min(...this.realms.map((t=>t.left))),this.maxY=Math.max(...this.realms.map((t=>t.bottom)))-1,this.minY=Math.min(...this.realms.map((t=>t.top)))}divide(){let t,i,s,o;const n=new Array(this.divideX),a=new Array(this.divideY),h=e.canvasHeight,r=e.canvasWidth,l=Math.floor(h/e.pixel),d=Math.floor(r/e.pixel);for(t=0;t<this.divideX;t+=1)n[t]=0;for(t=0;t<this.divideY;t+=1)a[t]=0;for(o=this.divideX,t=o;t<d;t+=1)n[Math.floor(Math.random()*this.divideX)]+=1;for(o=this.divideY,t=o;t<l;t+=1)a[Math.floor(Math.random()*this.divideY)]+=1;let c=1,m=2;for(t=0;t<this.divideX;t+=1){for(i=0;i<this.divideY;i+=1)s={left:c,right:c+n[t],top:m,bottom:m+a[i],sizeX:n[t],sizeY:a[i],id:this.realms.length,connectID:[]},this.realms.push(Object.assign({},s)),m+=a[i];m=2,c+=n[t]}}makeRoom(){let e,i,s,o,n,a,h,r,l,d,c,m;i=0,s=0,o=0,h=0,r=0,m=0;const p=(t,e,i,s,o)=>(t.roomLeft=e,t.roomTop=i,t.roomSizeX=s,t.roomSizeY=o,t.roomRight=e+s-1,t.roomBottom=i+o-1,t.visible=!1,t.know=!1,t);for(e=0;e<this.realms.length;e++){const u=this.realms[e];if(u.sizeX*u.sizeY<25)this.realms[e]=p(u,u.left+2,u.top+2,u.sizeX-4,u.sizeY-4);else{for(i=0,c=!0;c;){if(i+=1,i>100){h=u.sizeX-4,r=u.sizeY-4;break}l=u.sizeX-4,d=u.sizeY-4,h=t({max:l,min:5}),r=t({max:d,min:5}),m=h*r/(u.sizeX*u.sizeY),c=!0,h*r<25&&(c=!1),m<.4&&(c=!1)}n=u.sizeX-h-4,s=n>0?t({max:n,min:2}):2,a=u.sizeY-r-4,o=a>0?t({max:a,min:2}):2,this.realms[e]=p(u,u.left+s,u.top+o,h,r)}}}makePath(){let t,e,i;for(t=0;t<this.realms.length;t+=1)e=this.getAdjacentRealmIndices(t),i=Math.floor(Math.random()*e.length),this.addConnect(this.realms[t],this.realms[e[i]]);for(const t of this.connects)this.drawConnect(null,t,!1)}makePathObject(t,e){let i=this.pathPositions.find((i=>i.x===t&&i.y===e));i||(i={x:t,y:e,visible:!1,know:!1},this.pathPositions.push(i))}addConnect(e,i){let s,o,n,a,h,r;if(this.connects.some((t=>t.fromId===e.id&&t.toId===i.id||t.fromId===i.id&&t.toId===e.id)))return;const l={fromId:e.id,toId:i.id},d=e=>t({max:e.roomBottom-2,min:e.roomTop+2}),c=e=>t({max:e.roomRight-2,min:e.roomLeft+2});e.left===i.right&&(s=e.roomLeft-1,o=d(e),n=i.roomRight+1,a=d(i),r=e.roomLeft-e.left,h=3),i.left===e.right&&(s=e.roomRight+1,o=d(e),n=i.roomLeft-1,a=d(i),r=e.right-e.roomRight,h=1),e.top===i.bottom&&(s=c(e),o=e.roomTop-1,n=c(i),a=i.roomBottom+1,r=e.roomTop-e.top,h=0),i.top===e.bottom&&(s=c(e),o=e.roomBottom+1,n=c(i),a=i.roomTop-1,r=e.bottom-e.roomBottom,h=2),l.startX=s,l.startY=o,l.endX=n,l.endY=a,l.middle=r,l.direction=h,this.connects.push(Object.assign({},l)),e.connectID.push(i.id),i.connectID.push(e.id)}getAdjacentRealmIndices(t){const e=[],i=this.realms[t];for(let s=0;s<this.realms.length;s+=1)t!==s&&this.isAdjacent(i,this.realms[s])&&e.push(s);return e}isAdjacent(t,e){if(t.left===e.right||e.left===t.right){if(t.top<=e.bottom&&t.top>=e.top)return!0;if(t.bottom>=e.top&&t.bottom<=e.bottom)return!0}if(t.top===e.bottom||e.top===t.bottom){if(t.left>=e.left&&t.left<=e.right)return!0;if(t.right>=e.left&&t.right<=e.right)return!0}return!1}update(t){for(const t of this.realms)t.visible=!1;for(const t of this.pathPositions)t.visible=!1}draw(t){this.drawScaleLine(t.ctx);for(const e of this.realms)this.drawDivide(t.ctx,e),this.drawRoom(t.ctx,e);for(const e of this.connects)this.drawConnect(t.ctx,e)}drawScaleLine(t){t.strokeStyle="rgba(250, 250, 250, 0.25)",t.lineWidth=1;const i=e.canvasHeight,s=e.canvasWidth,o=Math.floor(i/e.pixel),n=Math.floor(s/e.pixel);let a;for(a=0;a<=o;a+=1)t.beginPath(),t.moveTo(0,e.pixel*a),t.lineTo(s,e.pixel*a),t.stroke(),t.closePath();for(a=0;a<=n;a+=1)t.beginPath(),t.moveTo(e.pixel*a,0),t.lineTo(e.pixel*a,i),t.stroke(),t.closePath();t.strokeStyle="rgba(250, 250, 250, 1)",t.strokeRect(s,i,n*e.pixel,o*e.pixel)}drawDivide(t,i){t.lineWidth=2,t.strokeStyle="rgba(250, 250, 250, 0.1)",t.fillStyle="rgba(250, 250, 250, 0.05)",t.strokeRect(i.left*e.pixel,i.top*e.pixel,i.sizeX*e.pixel,i.sizeY*e.pixel),t.fillRect(i.left*e.pixel,i.top*e.pixel,i.sizeX*e.pixel,i.sizeY*e.pixel)}drawRoom(t,i){t.lineWidth=2,t.strokeStyle=i.visible?this.stageColor1:this.stageColor2,t.fillStyle=i.visible?this.stageColor1:this.stageColor2,t.strokeRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel),(i.visible||i.know)&&t.fillRect(i.roomLeft*e.pixel,i.roomTop*e.pixel,i.roomSizeX*e.pixel,i.roomSizeY*e.pixel)}drawConnect(t,e,i=!0){var s,o,n,a,h;for(n=e.startX,a=e.startY,o=e.direction,h=e.middle,s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1);for(o%2==0?(h=Math.abs(e.startX-e.endX),e.startX>e.endX&&(o=3),e.startX<e.endX&&(o=1)):(h=Math.abs(e.startY-e.endY)+1,e.startY>e.endY&&(o=0),e.startY<e.endY&&(o=2)),s=0;s<h;s+=1)i?this.drawPath(t,n,a):this.makePathObject(n,a),s!==h-1&&(0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1));for(h=(o=e.direction)%2==0?Math.abs(a-e.endY):Math.abs(n-e.endX),s=0;s<h;s+=1)0===o&&(a-=1),1===o&&(n+=1),2===o&&(a+=1),3===o&&(n-=1),i?this.drawPath(t,n,a):this.makePathObject(n,a)}drawPath(t,i,s){const o=this.pathPositions.find((t=>t.x===i&&t.y===s));(o.visible||o.know)&&(t.fillStyle=o.visible?this.stageColor1:this.stageColor2,t.fillRect(e.pixel*i,e.pixel*s,e.pixel,e.pixel))}hitWall(t,e,i=["u"]){return!this.isInnerRoom(t,e)&&!this.isInnerPath(t,e,i)}isInnerRoom(t,e,i=!1){for(const s of this.realms)if(s.roomLeft<=t&&t<=s.roomRight&&s.roomTop<=e&&e<=s.roomBottom){if(i){s.visible=!0,s.know=!0;for(const t of this.pathPositions)t.x>=s.roomLeft-1&&t.x<=s.roomRight+1&&t.y>=s.roomTop-1&&t.y<=s.roomBottom+1&&(t.visible=!0,t.know=!0)}return s}return null}isInnerPath(t,i,s,o=!1){const n=s.length>0?s[0]:null;for(const s of this.pathPositions)if(s.x===t&&s.y===i){if(o){if(s.visible=!0,s.know=!0,"u"===n){for(let s=1;s<=e.visibleRange;s++)this.isInnerPath(t,i-s,[],o);this.isInnerPath(t+1,i,[],o),this.isInnerPath(t-1,i,[],o)}if("d"===n)for(let s=1;s<=e.visibleRange;s++)this.isInnerPath(t,i+s,[],o),this.isInnerPath(t+1,i,[],o),this.isInnerPath(t-1,i,[],o);if("l"===n)for(let s=1;s<=e.visibleRange;s++)this.isInnerPath(t-s,i,[],o),this.isInnerPath(t,i+1,[],o),this.isInnerPath(t,i-1,[],o);if("r"===n)for(let s=1;s<=e.visibleRange;s++)this.isInnerPath(t+s,i,[],o),this.isInnerPath(t,i+1,[],o),this.isInnerPath(t,i-1,[],o)}return s}return null}}class n{constructor(){this.loadCount=0,this.gamemode=e.gamemode.playing.val,this.keyboard=[],this.canvasEl=void 0,this.ctx=void 0,this.displayCtx=void 0,this.stage=new o;const n=()=>{const e=this.stage.realms[t({max:this.stage.realms.length-1,min:0})];return[t({max:e.roomRight,min:e.roomLeft}),t({max:e.roomBottom,min:e.roomTop})]},[a,h]=n();this.player=new i({x:a,y:h,height:e.pixel,width:e.pixel});const[r,l]=n();this.enemies=[new s({x:r,y:l,height:e.pixel,width:e.pixel})];const d=document.querySelector(e.appElementID);this._createCanvasEl(d),this.setKeyEvent(),this.stage.isInnerRoom(a,h,!0),this.stage.isInnerPath(a,h,["u"],!0)}setKeyEvent(){this.addKeydownEventListener(document,"keydown")}addKeydownEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[this._adjustKeyCode(t.code)]};i?t.addEventListener(e,(()=>s(i))):t.addEventListener(e,s)}addKeyupEventListener(t,e,i=void 0){const s=t=>{this.keyboard=[]};i?t.addEventListener(e,(()=>s())):t.addEventListener(e,s)}run(){this._draw()}_adjustKeyCode(t){const e={l:["ArrowLeft"],r:["ArrowRight"],u:["ArrowUp"],d:["ArrowDown"]};for(const[i,s]of Object.entries(e))if(s.includes(t))return i;return t}_createCanvasEl(t){const[i,s]=[e.canvasWidth,e.canvasHeight];let o=i;[t.style.width,t.style.height]=[`${o}px`,`${s}px`],this.canvasEl=document.createElement("canvas"),[this.canvasEl.width,this.canvasEl.height]=[i,s],this.ctx=this.canvasEl.getContext("2d");const n=document.createElement("canvas");[n.style.width,n.style.height]=[`${i}px`,`${s}px`],[n.width,n.height]=[i,s],this.displayCtx=n.getContext("2d"),t.appendChild(n)}_draw(t){if(10*Math.round(t/10)%500==0){this.ctx.save(),this.ctx.fillStyle="#205030",this.ctx.fillRect(0,0,e.canvasWidth,e.canvasHeight),this.stage.update(this),this.player.update(this),this.stage.draw(this);for(const t of this.enemies)t.update(this),t.draw(this);this.player.draw(this),this.ctx.restore(),this.displayCtx.drawImage(this.canvasEl,0,0)}Object.values(e.gamemode).find((t=>t.val===this.gamemode)).text||(this.timer=requestAnimationFrame(this._draw.bind(this)))}}class a extends n{setKeyEvent(){const t=document.querySelector("#leftbtn"),e=document.querySelector("#rightbtn"),i=document.querySelector("#upbtn"),s=document.querySelector("#downbtn");["mousedown","touchstart"].forEach((o=>{this.addKeydownEventListener(t,o,{codel:"l"}),this.addKeydownEventListener(e,o,{codel:"r"}),this.addKeydownEventListener(i,o,{codel:"u"}),this.addKeydownEventListener(s,o,{codel:"d"})}));["mouseup","touchend"].forEach((o=>{this.addKeyupEventListener(t,o,{codel:"l"}),this.addKeyupEventListener(e,o,{codel:"r"}),this.addKeyupEventListener(i,o,{codel:"u"}),this.addKeyupEventListener(s,o,{codel:"d"})}))}}const h=[],r=()=>{let t;t=navigator.userAgent.match(/iPhone|Android.+Mobile/)?new a:new n,t.run()};let l=0;0===h.length&&r();for(var d=0;d<h.length;++d)h[d].onload=function(){++l,l==h.length&&r()}})();